#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import json
import os
import re
import sys
from dataclasses import dataclass
from typing import Iterable, TextIO


@dataclass(frozen=True)
class Icon:
    name: str
    codepoint_hex: str
    glyph: str

    @property
    def codepoint_int(self) -> int:
        return int(self.codepoint_hex, 16)

    @property
    def printf_escape(self) -> str:
        hex_lower = self.codepoint_hex.lower().lstrip("0x")
        if len(hex_lower) <= 4:
            return "\\u" + hex_lower.zfill(4)
        if len(hex_lower) <= 8:
            return "\\U" + hex_lower.zfill(8)
        raise ValueError(f"codepoint too long: {self.codepoint_hex!r}")


def die(msg: str) -> None:
    print(f"nficon-export: {msg}", file=sys.stderr)
    raise SystemExit(2)


def default_csv_path() -> str:
    script_dir = os.path.dirname(os.path.realpath(__file__))
    env_csv = os.environ.get("NFICON_CSV")
    if env_csv:
        return env_csv

    data_home = os.environ.get("XDG_DATA_HOME") or os.path.join(
        os.path.expanduser("~"), ".local", "share"
    )
    xdg_csv = os.path.join(data_home, "nficon", "icons.csv")
    if os.path.isfile(xdg_csv):
        return xdg_csv

    return os.path.join(script_dir, "..", "skills", "nerd-fonts-icons", "icons.csv")


def load_icons(csv_path: str) -> list[Icon]:
    if not os.path.isfile(csv_path):
        die(f"missing icons CSV: {csv_path} (set NFICON_CSV to override)")

    with open(csv_path, "r", encoding="utf-8", newline="") as f:
        reader = csv.reader(f)
        try:
            header = next(reader)
        except StopIteration:
            die(f"empty CSV: {csv_path}")

        if header != ["name", "codepoint_hex", "glyph"]:
            die(
                "invalid CSV header; expected: name,codepoint_hex,glyph "
                f"(got: {','.join(header)})"
            )

        icons: list[Icon] = []
        for row in reader:
            if not row:
                continue
            if len(row) != 3:
                die(f"invalid CSV row (expected 3 columns): {row!r}")
            name, codepoint_hex, glyph = row
            icons.append(Icon(name=name, codepoint_hex=codepoint_hex, glyph=glyph))
        return icons


def filter_icons(icons: Iterable[Icon], prefix: str | None, pattern: str | None) -> list[Icon]:
    if prefix is None and pattern is None:
        return list(icons)

    rx: re.Pattern[str] | None = None
    if pattern is not None:
        try:
            rx = re.compile(pattern, flags=re.IGNORECASE)
        except re.error as exc:
            die(f"invalid --filter regex: {exc}")

    out: list[Icon] = []
    for icon in icons:
        if prefix is not None and not icon.name.startswith(prefix):
            continue
        if rx is not None and rx.search(icon.name) is None:
            continue
        out.append(icon)
    return out


def write_json(icons: list[Icon], mode: str, out: TextIO) -> None:
    if mode == "list":
        payload = [
            {
                "name": i.name,
                "codepoint_hex": i.codepoint_hex,
                "codepoint_int": i.codepoint_int,
                "glyph": i.glyph,
                "printf_escape": i.printf_escape,
            }
            for i in icons
        ]
    elif mode == "map":
        payload = {
            i.name: {
                "codepoint_hex": i.codepoint_hex,
                "glyph": i.glyph,
                "printf_escape": i.printf_escape,
            }
            for i in icons
        }
    else:
        die(f"unknown JSON mode: {mode}")

    json.dump(payload, out, ensure_ascii=False, indent=2, sort_keys=(mode == "map"))
    out.write("\n")


def write_tsv(icons: list[Icon], out: TextIO) -> None:
    out.write("name\tcodepoint_hex\tglyph\tprintf_escape\n")
    for i in icons:
        out.write(f"{i.name}\t{i.codepoint_hex}\t{i.glyph}\t{i.printf_escape}\n")


def write_toml(icons: list[Icon], out: TextIO) -> None:
    out.write("# Generated by agents/tools/nficon-export\n")
    out.write("# Format: one table per icon name\n\n")
    for i in icons:
        out.write(f'["{i.name}"]\n')
        out.write(f'codepoint_hex = "{i.codepoint_hex}"\n')
        out.write(f'glyph = "{i.glyph}"\n')
        out.write(f'printf_escape = "{i.printf_escape}"\n\n')


def write_lua(icons: list[Icon], out: TextIO) -> None:
    out.write("-- Generated by agents/tools/nficon-export\n")
    out.write("return {\n")
    for i in icons:
        out.write(
            f'  ["{i.name}"] = {{ codepoint_hex = "{i.codepoint_hex}", '
            f'glyph = "{i.glyph}", printf_escape = "{i.printf_escape}" }},\n'
        )
    out.write("}\n")


def write_sh(icons: list[Icon], out: TextIO) -> None:
    out.write("# Generated by agents/tools/nficon-export\n")
    out.write("# shellcheck shell=bash\n")
    out.write("\n")
    out.write("declare -Ar NFICON_CODEPOINT_HEX=(\n")
    for i in icons:
        out.write(f"  ['{i.name}']='{i.codepoint_hex}'\n")
    out.write(")\n\n")
    out.write("declare -Ar NFICON_GLYPH=(\n")
    for i in icons:
        out.write(f"  ['{i.name}']=$'{i.printf_escape}'\n")
    out.write(")\n\n")
    out.write("nficon_glyph() {\n")
    out.write("  local key=${1:?icon name required}\n")
    out.write('  printf "%b" "${NFICON_GLYPH[$key]:-}"\n')
    out.write("}\n")


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="nficon-export",
        description="Export Nerd Fonts icons.csv into ready-to-use formats.",
    )
    parser.add_argument("--csv", default=default_csv_path(), help="Path to icons.csv")
    parser.add_argument(
        "--format",
        required=True,
        choices=["json", "tsv", "toml", "lua", "sh"],
        help="Output format",
    )
    parser.add_argument(
        "--mode",
        default="map",
        choices=["map", "list"],
        help="JSON mode only (ignored for other formats)",
    )
    parser.add_argument("--prefix", help="Filter names by prefix (e.g. nf-cod-)")
    parser.add_argument("--filter", help="Regex filter on icon name (case-insensitive)")
    parser.add_argument(
        "--out",
        default="-",
        help="Output path, or '-' for stdout (default: '-')",
    )
    args = parser.parse_args()

    icons = load_icons(args.csv)
    icons = filter_icons(icons, prefix=args.prefix, pattern=args.filter)
    icons.sort(key=lambda i: i.name)

    if args.out == "-":
        out: TextIO
        out = sys.stdout
        close_out = False
    else:
        out_dir = os.path.dirname(os.path.realpath(args.out))
        if out_dir:
            os.makedirs(out_dir, exist_ok=True)
        out = open(args.out, "w", encoding="utf-8", newline="")
        close_out = True

    try:
        if args.format == "json":
            write_json(icons, mode=args.mode, out=out)
        elif args.format == "tsv":
            write_tsv(icons, out=out)
        elif args.format == "toml":
            write_toml(icons, out=out)
        elif args.format == "lua":
            write_lua(icons, out=out)
        elif args.format == "sh":
            write_sh(icons, out=out)
        else:
            die(f"unknown format: {args.format}")
    finally:
        if close_out:
            out.close()

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
